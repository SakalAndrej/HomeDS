\chapter{XIBO-Server}
\section{Beschreibung}
Als zentrale Steuereinheit wird ein XIBO-Server verwendet. Um diesen verwenden zu kÃ¶nnen, war es Notwendig sich in die Dokumentation einzulesen und die API-Schnittstelle auszuprobieren. Die Website des Servers diente vorerst als Ãbungsumgebung dadurch wurde es leicht auch die einzelnen Funktionen, inklusive der Vorgangsweise, des Servers zu verstehen.

\section{API-Schnittstelle}
Die API-Schnittstelle des XIBO-Servers ist mittels Swagger Dokumentiert, diese Dokumentation deckt die GrundfunktionalitÃ¤ten und die Form der Anfragen ab. Da die Schnittstelle des Servers spÃ¤ter als wesentliches VerbindungsstÃ¼ck zwischen der eigens entwickelten Steuerungssoftware und dem Server dient, war es NÃ¶tig diese grÃ¼ndlich zu Testen und diese auch zu verstehen. Anfangs wurde dafÃ¼r mit Postman gearbeitet. Um mit Postman die Requests testen zu kÃ¶nnen mussten festgestellt werden welche Codierung fÃ¼r den Request verwendet wird, im Falle des XIBO-Servers wird ''application/x-www-form-urlencoded'' als Codierung verwendet.


\section{Authentifizierung}
Es stellte sich heraus, dass die Authentifizierung mittels OAuth2 sehr speziell war was zu Beginn zu einigen Schwierigkeiten fÃ¼hrte, da es einige AnlÃ¤ufe brauchte um herauszufinden wie die Parameter Ã¼bergeben werden mÃ¼ssen und in welcher Reihenfolge. Dazu wurde eine Java-Klasse entwickelt welche die Authentifizierung automatisch Ã¼bernimmt.
VERWEIS!!!!!!!!!!!!!!!!!!
https://oauth.net/2/

Der Server benÃ¶tigt zur Authentifizierung mit einem Client eine Client_ID diese wird vom Server fÃ¼r jeden Client eindeutig erzeugt. Man bekommt sie direkt von der Website des Servers. 
Weiteres wird ein Client_Secret benÃ¶tigt welches ebenso wie die Client_ID vom Server,fÃ¼r jede Anwendung ,eindeutig erzeugt wird und auch auf der Website erhÃ¤ltlich ist. Zudem ist ein Parameter in der Form "&grant_type=client_credentials" mitzugeben.

Zuerst wird ein Request-Body erstellt dieser hat folgende Parameter in der Form: 
 ''client\_id=<CLIENT\_ID>\&client\_secret=<CLIENT\_SECRET>\&grant\_type=client\_credentials''
, die im Body mitgegeben werden und als Format 'application/x-www-form-urlencoded'  haben. AnschlieÃend werden dem Header noch der "content-type" mit dem Wert ''application/x-www-form-urlencoded'' und der Parameter ''cache-control'' mit dem Wert ''no-cache'' hinzugefÃ¼gt. Als ergebniss der Anfrage bekommt der Client einen '' access\_token '', dieser ist nun bei jeder Anfrage von NÃ¶ten um sich beim Server zu authentifizieren und es dem Client zu ermÃ¶glichen Daten abzurufen beziehungsweise weiterzugeben.

\section{Request-Helper}
Um in weiterer folge die Anfragen an den Digital Signage Server einfach und einheitlich durchzufÃ¼hren gibt es die Klasse "RequestHelper". In dieser Klasse gibt es neben den beiden Parametern "responseBody" und "responseCode", welche zur Fehlerausgabe und zum Erhalt der Daten aus der Anfrage vorhanden sind, auch noch die Methode "executeRequest", diese Ã¼bernimmt die Hauptaufgabe der Klasse und fÃ¼hrt die Anfragen an das Signage System durch.

Die Parameter dieser Methode Lauten wie folgt:

\begin{itemize}
	\item {\em RequestTypeEnum:} Der Parameter vom Typ Enum wird genutzt um Herauszufinden welche Http Anfrage vorliegt. MÃ¶gliche Werte sind hierbei GET, POST, PUT und DELETE.
	
	\item {\em Params:} Hier liegt eine HashMap vor, die als Key-Value Paare alle BenÃ¶tigten Parameter fÃ¼r den RequestBody beinhaltet. Beispielsweise: "LayoutID":"78", hierbei ist "LayoutID" der Key und "78" das Value.
		
	\item {\em Url:} Beinhaltet die URL unter der die Anfrage erreichbar ist. 
	
	\item {\em Token:} Ist jener Parameter der den '' access\_token '',der benÃ¶tigt wird um sich beim Server zu authentifizieren. Der Erhalt dieses Parameters, funktioniert wie bereits im vorigen Unterpunkt Authentifizierung beschrieben.
	
\end{itemize}

Zu beginn der Methode wird anhand des Parameters RequestTypeEnum unterschieden, um welche Http Anfrage es sich handelt. Wird GET oder DELETE geliefert wird durch die HashMap iteriert und die einzelnen Key-Value Paare als QeryParameter in der URL einfÃ¼gt. Beispielsweise: <URL>/layout?layoutID=78&token=ajdlfjÃÃwkflkd6545.
Handelt es sich um eine POST oder PUT Anfrage so werden die Key-Value Paare im Body mitgegeben und im Format "application/x-www-form-urlencoded" codiert. AnschlieÃend wird noch die URL mittels HttpUrl.Builder erstellt und ausgegeben. 
AnschlieÃend wird per Switch-Case dem Request die richtige Art der Anfrage zugewiesen und danach wird auch noch die URL Ã¼bergeben. 

Um die Anfragen noch fertig zu stellen wird noch das Interface Callback implementiert. Mit den beiden Methoden onFailure und onResponse wird dem Interface zugewiesen was passiert wenn der Request fehlschlÃ¤gt oder Funktioniert. 

Sollte der Request fehlschlagen so wird im Log-Fenster der Responsecode und die Fehlermeldung/Exception ausgegeben. 
Wird der Request ohne Fehler durchgefÃ¼hrt so wird im Log-Fenster ebenfalls der Responsecode und der Responsebody ausgegeben.

Der letzte Schritt ist es dem OkHttpClient mitzuteilen, dass er einen neuen Call ausfÃ¼hren soll, als Parameter wird der Zusammengestellte Request mitgegeben. Ãber .enwueue wird dem Client gesgat er soll auf einen Response warten Parameter fÃ¼r diese Methode ist das erstellte Interface Callback.






Als Ergebnis der Anfrage, mit den Parametern, in der Form
----------STÃ¼tz fragen ob bsp fÃ¼r request usw einbauen



